# 单链表

链表的结点是由数据域（可以是任何形式的数据）和指针域组成。

<u>**什么是链表？**</u>

<u>**链表就是结构体变量与结构体变量连接在一起（通过结构体指针连接在一起）！**</u>

动态创建链表：动态内存申请+模块化设计

1. 创建链表（创建一个表头表示整个链表）

2. 创建结点（形成新的结点）
3. 插入结点
4. 删除节点
5. 打印遍历链表（测试）

创建链表，链表表头

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
#include<stdlib.h>
#include<string.h>


struct Node
{
    int data;                  //数据域
    struct Node* next;         //指针域

};

//创建链表其实就是创建一个链表头来表示整个链表
//链表头是没有数据域的，只有指针域
//也就是说链表头不存储数据只有一个指向下一个结点的指针
struct Node* creatList() //创建链表
{
    struct Node* headNode = (struct Node*)malloc(sizeof(struct Node));//动态内存分配
    //动态内存分配后    headNode 就成为了结构体变量
    //变量使用前必须初始化
    //headNode->data = 1;
    headNode->next = NULL;
    return headNode;
}

//为什么要封装一个创建结点的功能？
//在插入结点时需要用到
struct Node* creatNode(int data) //创建结点
{
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;//结构体变量初始化   结构体变量里的data给的是形参
    newNode->next = NULL;//结构体变量里面的指针初始化为空
    return newNode;

}

//打印链表
void printList(struct Node* headNode)
{
    struct Node* pMove = headNode->next;
    while (pMove != NULL)
    {
        printf("%d\n", pMove->data);
        pMove = pMove->next;
    }
    printf("\n");
}

//插入结点：参数：插入哪个链表，插入结点的数据是多少 
//这里是表头法插入也就是头插法

void insertNodeBrHead(struct Node* headNode,int data)
{
    //1. 创建插入的结点
    struct Node* newNode = creatNode(data);
    //2. 开始插入结点   先链接在断开
    newNode->next = headNode->next;
    headNode->next = newNode;
}

//链表的删除：指定位置删除 
void deleteNodeByAppoin(struct Node* headNode, int posData)
{
    struct Node* posNode = headNode->next;
    struct Node* posNodeFront = headNode;
    if (posNode == NULL)
        printf("无法删除链表为空！\n");
    else
    {
        while (posNode->data != posData)
        {
            posNodeFront = posNode;
            posNode = posNodeFront->next;
            if (posNode == NULL)
            {
                printf("未找到相关信息无法删除！\n");
                return;
            }

        }
        posNodeFront->next = posNode->next;
        free(posNode);
    }
}

int main()
{
    struct Node* list = creatList();//这里也就是我创建了一个叫list的链表

    insertNodeBrHead(list, 1);
    insertNodeBrHead(list, 2);
    insertNodeBrHead(list, 3);

    printList(list);//打印出来结果是321
    deleteNodeByAppoin(list, 2);//删除了2
    printList(list);//结果是31
    system("pause");

    return 0;
}
```

![image-20220602164822522](C:\Users\22260\AppData\Roaming\Typora\typora-user-images\image-20220602164822522.png)

这里是链表的指定位置删除的示意图

我们只需要找到posNode和posNodeFront就可以

将posNodeFront->next变为posNode->next就完成删除

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
#include<stdlib.h>
#include<string.h>


//这里演示在实际工程中链表的数据域是一个结构体时怎样完成
struct student
{
    char name[20];
    int math;
    int num;
};

struct Node
{
    struct student data;                  //数据域
    struct Node* next;         //指针域

};

//创建链表其实就是创建一个链表头来表示整个链表
//链表头是没有数据域的，只有指针域
//也就是说链表头不存储数据只有一个指向下一个结点的指针
struct Node* creatList() //创建链表
{
    struct Node* headNode = (struct Node*)malloc(sizeof(struct Node));//动态内存分配
    //动态内存分配后    headNode 就成为了结构体变量
    //变量使用前必须初始化
    //headNode->data = 1;
    headNode->next = NULL;
    return headNode;
}

//为什么要封装一个创建结点的功能？
//在插入结点时需要用到
struct Node* creatNode(struct student data) //创建结点
{
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;//结构体变量初始化   结构体变量里的data给的是形参
    newNode->next = NULL;//结构体变量里面的指针初始化为空
    return newNode;

}

//打印链表
void printList(struct Node* headNode)
{
    struct Node* pMove = headNode->next;
    printf("name\tnum\tmath\n");
        while (pMove != NULL)
        {
            //在结构体打印的时候剥洋葱
            printf("%s\t%d\t%d\n", pMove->data.name, pMove->data.num, pMove->data.math);
            pMove = pMove->next;
        }
    printf("\n");
}

//插入结点：参数：插入哪个链表，插入结点的数据是多少 
//这里是表头法插入也就是头插法
void insertNodeByHead(struct Node* headNode, struct student data)
{
    //1. 创建插入的结点
    struct Node* newNode = creatNode(data);
    //2. 开始插入结点   先链接在断开
    newNode->next = headNode->next;
    headNode->next = newNode;
}

//链表的删除：指定位置删除 
void deleteNodeByAppoinNum(struct Node* headNode, int num)
{
    struct Node* posNode = headNode->next;
    struct Node* posNodeFront = headNode;
    if (posNode == NULL)
        printf("无法删除链表为空！\n");
    else
    {
        while (posNode->data.num != num)
        {
            posNodeFront = posNode;
            posNode = posNodeFront->next;
            if (posNode == NULL)
            {
                printf("未找到相关信息无法删除！\n");
                return;
            }

        }
        posNodeFront->next = posNode->next;
        free(posNode);
    }
}

int main()
{
    struct Node* list = creatList();//这里也就是我创建了一个叫list的链表
    struct student info;
    while (1)
    {
        printf("请输入学生的姓名 学号 数学成绩：\n");
        scanf("%s%d%d", info.name, &info.num, &info.math);//在这里可以看出结构体的第一个元素就是一个地址
        setbuf(stdin, NULL);//清空缓冲区

        insertNodeByHead(list, info);
        printf("是否继续？(Y/N)?\n");

        setbuf(stdin, NULL);//清空缓冲区
        int choice = getchar();
        if (choice == 'n' || choice == 'N')
        {
            break;
        }

    }
    printList(list);
    printf("请输入要删除的学生的学号：\n");
    scanf("%d", &info.num);

    deleteNodeByAppoinNum(list, info.num);


    printList(list);
    system("pause");

    return 0;
}
```





























